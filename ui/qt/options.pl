#!/usr/bin/perl -w

# options.pl: generate options dialog boxes

# Copyright (c) 2002-2015 Philip Kendall

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Author contact information:

# E-mail: philip-fuse@shadowmagic.org.uk

use strict;

use Fuse;
use Fuse::Dialog;

die "No data file specified" unless @ARGV;

my @dialogs = Fuse::Dialog::read( shift @ARGV );

my %combo_sets;
my %combo_default;

print Fuse::GPL( 'options.cpp: options dialog boxes',
                 '2001-2024 Philip Kendall, ZXLDR' ) . << "CODE";

/* This file is autogenerated from options.dat by options.pl.
   Do not edit unless you know what you\'re doing! */

extern "C" 
{
  #include "config.h"
}

#ifdef UI_QT                /* Use this file if we're using QT */

extern "C" 
{
  #include "compat.h"
  #include "display.h"
  #include "fuse.h"
  #include "options.h"
  #include "options_internals.h"
  #include "periph.h"
  #include "settings.h"
  #include "utils.h"
}

#include <QDialog>
#include <QComboBox>
#include <QLineEdit>
#include <QLabel>
#include <QBoxLayout>
#include <QCheckBox>
#include <QGroupBox>
#include <QPushButton>

static int
option_enumerate_combo( const char * const *options, char *value, int count,
                        int def )
{
  int i;
  if( value != NULL ) {
    for( i = 0; i < count; i++) {
      if( !strcmp( value, options[ i ] ) )
        return i;
    }
  }
  return def;
}

CODE

foreach( @dialogs ) {

    foreach my $widget ( @{ $_->{widgets} } ) {

	foreach my $type ( $widget->{type} ) {

	    my $text = $widget->{text}; $text =~ tr/()//d;

	    if( $type eq "Combo" ) {
		my $n = 0;

		foreach( split( /\|/, $widget->{data1} ) ) {
		    if( /^\*/ ) {
			$combo_default{$widget->{value}} = $n;
		    }
		    $n++;
		}
		$n = 0;
		$widget->{data1} =~ s/^\*//;
		$widget->{data1} =~ s/\|\*/|/;
		if( not exists( $combo_sets{$widget->{data1}} ) ) {
		    $combo_sets{$widget->{data1}} = "$_->{name}_$widget->{value}_combo";

		    print << "CODE";

static const char * const $_->{name}_$widget->{value}_combo[] = {
CODE
		    foreach( split( /\|/, $widget->{data1} ) ) {
			print << "CODE";
  "$_",
CODE
			$n++;
		    }
		    print << "CODE";
};

static const int $_->{name}_$widget->{value}_combo_count = $n;

CODE
		} else {
		    print << "CODE";
\#define $_->{name}_$widget->{value}_combo $combo_sets{$widget->{data1}}
\#define $_->{name}_$widget->{value}_combo_count $combo_sets{$widget->{data1}}_count

CODE
		}
		print << "CODE";
int
option_enumerate_$_->{name}_$widget->{value}( void )
{
  return option_enumerate_combo( $_->{name}_$widget->{value}_combo,
                                 settings_current.$widget->{value},
                                 $_->{name}_$widget->{value}_combo_count,
                                 $combo_default{$widget->{value}} );
}

CODE
	    }
	}
    }

    print << "CODE";

void
menu_options_$_->{name}( int action )
{
  QWidget *content_area;
  menu_options_$_->{name}_t dialog;

  /* Firstly, stop emulation */
  fuse_emulation_pause();

  /* Create the necessary widgets */
  QDialog * _dialog = new QDialog( DeFuseWindow::instance() );
  _dialog->setWindowTitle("De-Fuse - $_->{title}");
  QVBoxLayout * _vbox = new QVBoxLayout();
  _dialog->setLayout(_vbox); 
  dialog.dialog = _dialog;
 
  /* Create the various widgets */
CODE

    foreach my $widget ( @{ $_->{widgets} } ) {

	foreach my $type ( $widget->{type} ) {

	    my $text = $widget->{text}; $text =~ tr/()//d;

	    if( $type eq "Checkbox" ) {

		print << "CODE";
  {
    QCheckBox * _cb = new QCheckBox( "$text" );
    _cb->setChecked( settings_current.$widget->{value} );
    _vbox->addWidget( dialog.$widget->{value} = _cb );
  }
CODE
            } elsif( $type eq "Entry" ) {

		print << "CODE";
  {
    QGroupBox * _gb = new QGroupBox( "$text" );
    QHBoxLayout * _hbox = new QHBoxLayout();
    _hbox->addWidget( new QLabel( "$widget->{data2}" ) );
    QLineEdit * _edit = new QLineEdit( QString::number( settings_current.$widget->{value} ) );
    _edit->setMaxLength( $widget->{data1} );
    _hbox->addWidget( dialog.$widget->{value} = _edit );
    _gb->setLayout(_hbox);
    _vbox->addWidget( _gb );
  }

CODE
            } elsif( $type eq "Combo" ) {

		print << "CODE";
  {
    QHBoxLayout * _hbox = new QHBoxLayout();
    _hbox->addWidget( new QLabel( "$text" ) );
    QComboBox * _combo = new QComboBox();
    for( int i = 0; i < $_->{name}_$widget->{value}_combo_count; i++ ) {
      _combo->addItem( $_->{name}_$widget->{value}_combo[i] );
    }
    _combo->setCurrentIndex( $combo_default{$widget->{value}} );
    _hbox->addWidget( dialog.$widget->{value} = _combo );
    _vbox->addLayout( _hbox );
  }

CODE
	    } else {
		die "Unknown type `$type'";
	    }
	}
    }

    print << "CODE";
  /* Create the OK and Cancel buttons */

  QPushButton * _ok = DeFuseWindow::addOkCancelButtons( _dialog );
  QObject::connect( _ok, &QPushButton::clicked, [=]() {
    menu_options_$_->{name}_t *ptr = & dialog;
CODE

    if( $_->{postcheck} ) {

      print << "CODE";
    /* Get a copy of current settings */
    settings_info original_settings;
    memset( &original_settings, 0, sizeof( settings_info ) );
    settings_copy( &original_settings, &settings_current );

CODE

    }

    foreach my $widget ( @{ $_->{widgets} } ) {

	if( $widget->{type} eq "Checkbox" ) {

	    print << "CODE";
    settings_current.$widget->{value} = dynamic_cast<QCheckBox *>( ptr->$widget->{value} )->isChecked();

CODE
        } elsif( $widget->{type} eq "Entry" ) {

	    print << "CODE";
    settings_current.$widget->{value} = dynamic_cast<QLineEdit *>( ptr->$widget->{value} )->text().toInt();

CODE
        } elsif( $widget->{type} eq "Combo" ) {

	    print << "CODE";
    libspectrum_free( settings_current.$widget->{value} );
    settings_current.$widget->{value} = dynamic_cast<QComboBox *>( ptr->$widget->{value} )->currentIndex();

CODE
    	} else {
	    die "Unknown type `$widget->{type}'";
	}
    }

    if( $_->{postcheck} ) {

      print << "CODE";
    int needs_hard_reset = $_->{postcheck}();

    /* Confirm reset */
    if( needs_hard_reset && !DeFuseWindow::instance()->ask("Some options need to reset the machine. Reset?" ) ) {

      /* Cancel new settings */
      settings_copy( &settings_current, &original_settings );
      settings_free( &original_settings );
      return;
    }

    settings_free( &original_settings );

CODE

    }

    print "  $_->{posthook}();\n\n" if $_->{posthook};

    print << "CODE";
    // TODO:    gtkstatusbar_set_visibility( settings_current.statusbar );
    display_refresh_all();

  });

  /* Display the window */
  /* Process events until the window is done with */
  _dialog->exec();
  delete _dialog;

  /* And then carry on with emulation again */
  fuse_emulation_unpause();

}
CODE

}

print << "CODE"

#endif			/* #ifdef UI_QT */
CODE
